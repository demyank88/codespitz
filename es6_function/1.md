
#  Sub Routine

## Sub Routine Flow

- Flow - 메모리에 적재된 명령이 한번에 실행되는것, Sync 동기화 명령
- Routine - 하나의 Flow 그 자체, 여러번 실행 할 수 있는것
- Sub Routine - Routine에 상대적인 의미, 무엇을 기준으로 보냐가 판단의 기준, Main Flow가 아니라 다른 Flow에서 실행되는 Routine
  - 자신을 호출한 Main Flow로 돌아간다.
  - 메인에서 서브로 보낼때는 메인에 어디로 돌아올지 지정해 놓는다.
  - 일반적으로 서브루틴에게 돌아올 지점까지 같이 보낸다.
  - 프로그램이 일정하게 흐르지 않게 된다.
  - 플로우의 통제를 다른쪽에 주었다가 빼는다고 생각해야한다.

- 애로우 함수
  - 함수에서 this가 필요한가? this가 필요한것은 메소드

- 메인플로에서 서브루틴으로는 인자를 보내고, 서브루틴에서 메인으로 값을 전달할때는 리턴을 사용한다.
- 서브루틴은 리턴 포인트를 알고 있다.
  - JS는 리턴 없는 루틴이 없다. 
  - 대부분의 언어는 리턴을 할 수 있는 루틴과 없는 루틴으로 구분된다.

- 루틴과 메인플로우의 대화 방법
  - 메인플로우에 리턴을 많이 받게 되면 어떻게 되는가?
    - 더하기를 제거하고 연산자를 제거하는것이 꼬리물기의 최적화, 스택메모리를 만들어내는 연산
  - 서브루틴안에 서브루틴이 있으면?
    - 각각의 루틴의 앞 단계에 있는 루틴만 알고 있다.
    - 서브루틴에서 또 다른 서브루틴을 실행하면 Keep이 일어난다. 루틴을 메모리를 가져야만 한다.
    - 루틴을 두번 반복하면 keep하지 않으면 두번째 루틴으로 갈 수가 없다.
    - 콜스택, 함수의 스택 메모리, js는 표준에서 백번 정도?
    - 루틴 안에 루틴이 쌓이는 만큼 스택 메모리가 쌓이고 스택 오버 플로우가 발생한다.

- 값과 참조
  - 값은 메모리 상에서 복사
  - 참조는 메모리의 주소를 공유
  - 인자와 리턴을 이용한 통신에서 값이냐 참조냐에 따라 다른 양상이 발생한다.
  - 값으로 인자를 보내가 리턴 받으면 의존성이 약해진다.
  - 값으로 보는 타입을 프리머티브 타입이라 한다.
  - 값은 언어가 정하는것, 기본 값이 아니면 다 참조.
  - 값 만을 사용하면 플로우 내에 서로 다른 루틴끼리 영향을 주지 않는다. - state safe - 상태 안전
  - 함수형 프로그래밍 - 값을 컨택스트로 사용한다.
  - 값과 값으로만 되어 있는 함수를 짜자~
  - 참조가 넘어오는것은 어쩔수 없지만 Read only로 사용하자.
  ```js
  const routine = ({a, b, ...rest}) => rest;
  const ref = { a: 1, b: 2, c: 3, d:4 };
  const a = routine(ref);
  ref !== a //true
  ```
  - 지역 변수를 만들때도 새로운 Object로 
  ```js
  const routine = ref => ({...ref, d:7});
  const ref = { a: 1, b: 2, c: 3, d:4 };
  const a = routine(ref);
  ref !== a //true
  ```


# Structured Design 
> 래리 콘스탄틴 - 좋은 서브루틴이란 높은 응집도, 낮은 결합도

- 결합도(Coupling) - content, common, external, control, stamp, data
- 응집도(Dependency) - coincidental, logical, ...

## 결합도 (Coupling)
- Content - 강결합
  - 의존하는 대상의 내장을까서 다 알고 있는 경우, 내장까는 코드는 다 않좋다.
- Common - 강결합
  - 전역객체, 글로벌 객체
  - 커먼 객체를 참조해서 여러 객체를 만드는 경우 ...
  - 커먼을 변경시 참조한 객체들이 다 영향을 받음

- External - 강결합
  - 회피할 방법이 없다, 정복해야한다. 위두개는 배제 해야됨
  - 커먼은 우리가 직접 만든것, 익스터널은 외부에서 만들어진것.
  - api 요청을 할 경우, 그 스펙을 알고 있어야 한다.
  - 스펙이 없으면 바로 throw로 에러 날리는것

- Control - 강결합
  - 현대의 디자인 패턴을 포함해 회피 할수 있다.
  - 루틴의 문제, 대상 객체를 주지 않고 대상 객체의 힌트를 주는 경우 발생한다.
  - 메뉴판, 레시피, 메뉴, 플래그로만, 직접 객체가 아닌 힌트를 줘서 실행하는 경우.
  - 플래그형 변수 - 오더를 내리기 위한 기호 변수를 넘기는 것
  - 플래그 변수가 흐름제어를 관여하게 된다.
  - 팩토리 패턴에서 가장 많이 일어나는 오류
  - 진짜 팩토리 패턴을 만들려면, 추상 팩토리 패턴을 만들어야 한다.
  - `어떻게 해체 하는가? - 전략 패턴을 이용하면 된다.`

- Stamp - 강결합, 유사악결합
  - 좁은 범위를 줘야 하는데 넓은 범위를 주었기 때문에 깨지는 것이 발생할수 잇다.
  - 필요한데 까지만 값을 줘야 한다.
  - 넓은 범위의 값을 갖게 되면 의존성이 생기게 된다.

- Data - 약결합
  - 필요한 값만 보내는것.
  - 결합도가 여기까지 내려와야 한다.
  - 값으로 통신을 바꾼것이 우연이 아니다.
  - 값으로 대화하면 커플링을 줄이는 효과가 있다.

> 얘 때문에 애를 수정할 수 없게 되나? 항상 고민 해야한다.


## 응집도 (Cohesion) 
- Coincidental
  - 우연히 모여있는 애들
  - 가장 응집성이 나쁜애들, 만든 사람 외에는 왜그런지 모른다.

- Logical
  - 로직의 나쁜점은? 교육 수준 상식의 수준이 비슷한 사람만이 알 수 있다.
  - 동등한 도메인 지식을 가진 사람들이 인식할 수 있는것.
  - 도메인이 특수하지 않으면 일반적이면 써도 된다.
  - 도메인이 특수할수록 쓰면 안된다.

- Temporal
  - 시간의 순서
  - 초기화? 컴퓨터의 시간은 순서를 의미한다.
  - 시간에 대한 의존성은 시간의 흐름으로 사람이 사고하는게 자연스럽기 때문에
  - 로직을 짜는 세상이기 때문에 위험하다.

- Procedural
  - 절차적 순서
  - 이렇게 실행하겠다 절차를 정한것.
  - 우리가 로직적으로 생각해낸 절차.
  - `그래서 프로그램 짜기전에 의사코드를 잘짜는것이 중요.`

- Comunicational
  - 역할에 따라서 역할이 뭔지 설명하라하면 권한과 책임, 권한과 책임이 역할을 만들어 낸다. 
  - 단일 책임 원칙 - 하나의 객체가 하나의 역할만 수행
  - 단일 역할만 수행하도록 만들어줘야 에러가 없어진다.
  - 배열을 다루려면 배열 내부에 메소드만 쓰면된다 생각할수 있도록 만드는것.

- Sequential
  - 실행순서가 밀접하게 연결되고, 프로시져와 커뮤니케이셔널을 합쳐놓은것.
  - `빌더 패턴`
  - 앞에 실행결과와 뒤에 실행결과가 밀접하게 연결되어 있는것. 채이닝되는 코드

- Functional
  - 역할 모델에 충실하게 단일한 기능이 의존성 없이 생성된 경우

> 하지만... 높은 응집성을 가지면 높은 결합성을 갖게 된다. 응집성이 낮아지면 결합성이 낮아 진다. 이상적으로 낮은 결합도 높은 응집성을 동시에 달성되기 어렵다. 두개의 밸런스에서 합치를 봐야 한다.

> 어느 수준에서 응집성과 결합성의 밸런스를 맞출 것인가?
